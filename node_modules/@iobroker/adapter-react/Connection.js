"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ERRORS = exports.PROGRESS = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** Possible progress states. */
var PROGRESS = {
  /** The socket is connecting. */
  CONNECTING: 0,

  /** The socket is successfully connected. */
  CONNECTED: 1,

  /** All objects are loaded. */
  OBJECTS_LOADED: 2,

  /** The socket is ready for use. */
  READY: 3
};
exports.PROGRESS = PROGRESS;
var PERMISSION_ERROR = 'permissionError';
var NOT_CONNECTED = 'notConnectedError';
var ERRORS = {
  PERMISSION_ERROR: PERMISSION_ERROR,
  NOT_CONNECTED: NOT_CONNECTED
};
exports.ERRORS = ERRORS;

var Connection = /*#__PURE__*/function () {
  /**
   * @param {import('./types').ConnectionProps} props
   */
  function Connection(props) {
    _classCallCheck(this, Connection);

    props = props || {
      protocol: window.location.protocol,
      host: window.location.hostname
    };
    this.props = props;
    this.autoSubscribes = this.props.autoSubscribes || [];
    this.autoSubscribeLog = this.props.autoSubscribeLog;
    this.props.protocol = this.props.protocol || window.location.protocol;
    this.props.host = this.props.host || window.location.hostname;
    this.props.port = this.props.port || (window.location.port === '3000' ? 8081 : window.location.port);
    this.props.ioTimeout = Math.max(this.props.ioTimeout || 20000, 20000);
    this.props.cmdTimeout = Math.max(this.props.cmdTimeout || 5000, 5000); // breaking change. Do not load all objects by default is true

    this.doNotLoadAllObjects = this.props.doNotLoadAllObjects === undefined ? true : this.props.doNotLoadAllObjects;
    this.doNotLoadACL = this.props.doNotLoadACL === undefined ? true : this.props.doNotLoadACL;
    /** @type {Record<string, ioBroker.State>} */

    this.states = {};
    this.objects = null;
    this.acl = null;
    this.firstConnect = true;
    this.waitForRestart = false;
    /** @type {ioBroker.Languages} */

    this.systemLang = 'en';
    this.connected = false;
    /** @type {Record<string, { reg: RegExp; cbs: ioBroker.StateChangeHandler[]}>} */

    this.statesSubscribes = {}; // subscribe for states

    /** @type {Record<string, { reg: RegExp; cbs: import('./types').ObjectChangeHandler[]}>} */

    this.objectsSubscribes = {}; // subscribe for objects

    this.onProgress = this.props.onProgress || function () {};

    this.onError = this.props.onError || function (err) {
      console.error(err);
    };

    this.loaded = false;
    this.loadTimer = null;
    this.loadCounter = 0;
    this.certPromise = null;
    /** @type {((connected: boolean) => void)[]} */

    this.onConnectionHandlers = [];
    /** @type {((message: string) => void)[]} */

    this.onLogHandlers = [];
    /** @type {Record<string, Promise<any>>} */

    this._promises = {};
    this.startSocket();
  }
  /**
   * Checks if this connection is running in a web adapter and not in an admin.
   * @returns {boolean} True if running in a web adapter or in a socketio adapter.
   */


  _createClass(Connection, [{
    key: "startSocket",
    value:
    /**
     * Starts the socket.io connection.
     * @returns {void}
     */
    function startSocket() {
      var _this = this;

      // if socket io is not yet loaded
      if (typeof window.io === 'undefined') {
        // if in index.html the onLoad function not defined
        if (typeof window.registerSocketOnLoad !== 'function') {
          // poll if loaded
          this.scriptLoadCounter = this.scriptLoadCounter || 0;
          this.scriptLoadCounter++;

          if (this.scriptLoadCounter < 30) {
            // wait till the script loaded
            setTimeout(function () {
              return _this.startSocket();
            }, 100);
            return;
          } else {
            window.alert('Cannot load socket.io.js!');
          }
        } else {
          // register on load
          window.registerSocketOnLoad(function () {
            return _this.startSocket();
          });
        }

        return;
      } else {
        // socket was initialized, do not repeat
        if (this._socket) {
          return;
        }
      }

      var host = this.props.host;
      var port = this.props.port;
      var protocol = this.props.protocol.replace(':', ''); // if web adapter, socket io could be on other port or even host

      if (window.socketUrl) {
        var parts = window.socketUrl.split(':');
        host = parts[0] || host;
        port = parts[1] || port;

        if (host.includes('://')) {
          parts = host.split('://');
          protocol = parts[0];
          host = parts[1];
        }
      }

      var url = "".concat(protocol, "://").concat(host, ":").concat(port);
      this._socket = window.io.connect(url, {
        query: 'ws=true',
        name: this.props.name,
        timeout: this.props.ioTimeout
      });

      this._socket.on('connect', function (noTimeout) {
        // If the user is not admin it takes some time to install the handlers, because all rights must be checked
        if (noTimeout !== true) {
          setTimeout(function () {
            return _this.getVersion().then(function (info) {
              var _info$version$split = info.version.split('.'),
                  _info$version$split2 = _slicedToArray(_info$version$split, 3),
                  major = _info$version$split2[0],
                  minor = _info$version$split2[1],
                  patch = _info$version$split2[2];

              var v = parseInt(major, 10) * 10000 + parseInt(minor, 10) * 100 + parseInt(patch, 10);

              if (v < 40102) {
                _this._authTimer = null; // possible this is old version of admin

                _this.onPreConnect(false, false);
              } else {
                _this._socket.emit('authenticate', function (isOk, isSecure) {
                  return _this.onPreConnect(isOk, isSecure);
                });
              }
            });
          }, 500);
        } else {
          // iobroker websocket waits, till all handlers are installed
          _this._socket.emit('authenticate', function (isOk, isSecure) {
            return _this.onPreConnect(isOk, isSecure);
          });
        }
      });

      this._socket.on('reconnect', function () {
        _this.onProgress(PROGRESS.READY);

        _this.connected = true;

        if (_this.waitForRestart) {
          window.location.reload(false);
        } else {
          _this._subscribe(true);

          _this.onConnectionHandlers.forEach(function (cb) {
            return cb(true);
          });
        }
      });

      this._socket.on('disconnect', function () {
        _this.connected = false;
        _this.subscribed = false;

        _this.onProgress(PROGRESS.CONNECTING);

        _this.onConnectionHandlers.forEach(function (cb) {
          return cb(false);
        });
      });

      this._socket.on('reauthenticate', function () {
        return _this.authenticate();
      });

      this._socket.on('log', function (message) {
        _this.props.onLog && _this.props.onLog(message);

        _this.onLogHandlers.forEach(function (cb) {
          return cb(message);
        });
      });

      this._socket.on('error', function (err) {
        var _err = err || '';

        if (typeof _err.toString !== 'function') {
          _err = JSON.stringify(_err);
          console.error("Received strange error: ".concat(_err));
        }

        _err = _err.toString();

        if (_err.includes('User not authorized')) {
          _this.authenticate();
        } else {
          window.alert("Socket Error: ".concat(err));
        }
      });

      this._socket.on('connect_error', function (err) {
        return console.error("Connect error: ".concat(err));
      });

      this._socket.on('permissionError', function (err) {
        return _this.onError({
          message: 'no permission',
          operation: err.operation,
          type: err.type,
          id: err.id || ''
        });
      });

      this._socket.on('objectChange', function (id, obj) {
        return setTimeout(function () {
          return _this.objectChange(id, obj);
        }, 0);
      });

      this._socket.on('stateChange', function (id, state) {
        return setTimeout(function () {
          return _this.stateChange(id, state);
        }, 0);
      });

      this._socket.on('cmdStdout', function (id, text) {
        return _this.onCmdStdoutHandler && _this.onCmdStdoutHandler(id, text);
      });

      this._socket.on('cmdStderr', function (id, text) {
        return _this.onCmdStderrHandler && _this.onCmdStderrHandler(id, text);
      });

      this._socket.on('cmdExit', function (id, exitCode) {
        return _this.onCmdExitHandler && _this.onCmdExitHandler(id, exitCode);
      });
    }
    /**
     * Called internally.
     * @private
     * @param {boolean} isOk
     * @param {boolean} isSecure
     */

  }, {
    key: "onPreConnect",
    value: function onPreConnect(isOk, isSecure) {
      var _this2 = this;

      if (this._authTimer) {
        clearTimeout(this._authTimer);
        this._authTimer = null;
      }

      this.connected = true;
      this.isSecure = isSecure;

      if (this.waitForRestart) {
        window.location.reload(false);
      } else {
        if (this.firstConnect) {
          // retry strategy
          this.loadTimer = setTimeout(function () {
            _this2.loadTimer = null;
            _this2.loadCounter++;

            if (_this2.loadCounter < 10) {
              _this2.onConnect();
            }
          }, 1000);

          if (!this.loaded) {
            this.onConnect();
          }
        } else {
          this.onProgress(PROGRESS.READY);
        }

        this._subscribe(true);

        this.onConnectionHandlers.forEach(function (cb) {
          return cb(true);
        });
      }
    }
    /**
     * Checks if the socket is connected.
     * @returns {boolean} true if connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.connected;
    }
    /**
     * Called internally.
     * @private
     */

  }, {
    key: "_getUserPermissions",
    value: function _getUserPermissions(cb) {
      if (this.doNotLoadACL) {
        return cb && cb();
      } else {
        this._socket.emit('getUserPermissions', cb);
      }
    }
    /**
     * Called internally.
     * @private
     */

  }, {
    key: "onConnect",
    value: function onConnect() {
      var _this3 = this;

      this._getUserPermissions(function (err, acl) {
        if (err) {
          return _this3.onError('Cannot read user permissions: ' + err);
        } else if (!_this3.doNotLoadACL) {
          if (_this3.loaded) {
            return;
          }

          _this3.loaded = true;
          clearTimeout(_this3.loadTimer);
          _this3.loadTimer = null;

          _this3.onProgress(PROGRESS.CONNECTED);

          _this3.firstConnect = false;
          _this3.acl = acl;
        } // Read system configuration


        return _this3.getCompactSystemConfig().then(function (data) {
          if (_this3.doNotLoadACL) {
            if (_this3.loaded) {
              return;
            }

            _this3.loaded = true;
            clearTimeout(_this3.loadTimer);
            _this3.loadTimer = null;

            _this3.onProgress(PROGRESS.CONNECTED);

            _this3.firstConnect = false;
          }

          _this3.systemConfig = data;

          if (_this3.systemConfig && _this3.systemConfig.common) {
            _this3.systemLang = _this3.systemConfig.common.language;
          } else {
            _this3.systemLang = window.navigator.userLanguage || window.navigator.language;

            if (_this3.systemLang !== 'en' && _this3.systemLang !== 'de' && _this3.systemLang !== 'ru') {
              _this3.systemConfig.common.language = 'en';
              _this3.systemLang = 'en';
            }
          }

          _this3.props.onLanguage && _this3.props.onLanguage(_this3.systemLang);

          if (!_this3.doNotLoadAllObjects) {
            return _this3.getObjects().then(function () {
              _this3.onProgress(PROGRESS.READY);

              _this3.props.onReady && _this3.props.onReady(_this3.objects);
            });
          } else {
            _this3.objects = {
              'system.config': data
            };

            _this3.onProgress(PROGRESS.READY);

            _this3.props.onReady && _this3.props.onReady(_this3.objects);
          }
        })["catch"](function (e) {
          return _this3.onError('Cannot read system config: ' + e);
        });
      });
    }
    /**
     * Called internally.
     * @private
     */

  }, {
    key: "authenticate",
    value: function authenticate() {
      if (window.location.search.includes('&href=')) {
        window.location = "".concat(window.location.protocol, "//").concat(window.location.host).concat(window.location.pathname).concat(window.location.search).concat(window.location.hash);
      } else {
        window.location = "".concat(window.location.protocol, "//").concat(window.location.host).concat(window.location.pathname, "?login&href=").concat(window.location.search).concat(window.location.hash);
      }
    }
    /**
     * Subscribe to changes of the given state.
     * @param {string} id The ioBroker state ID.
     * @param {ioBroker.StateChangeHandler} cb The callback.
     */

    /**
    * Subscribe to changes of the given state.
    * @param {string} id The ioBroker state ID.
    * @param {boolean} binary Set to true if the given state is binary and requires Base64 decoding.
    * @param {ioBroker.StateChangeHandler} cb The callback.
    */

  }, {
    key: "subscribeState",
    value: function subscribeState(id, binary, cb) {
      if (typeof binary === 'function') {
        cb = binary;
        binary = false;
      }

      if (!this.statesSubscribes[id]) {
        var reg = id.replace(/\./g, '\\.').replace(/\*/g, '.*').replace(/\(/g, '\\(').replace(/\)/g, '\\)').replace(/\+/g, '\\+').replace(/\[/g, '\\[');

        if (reg.indexOf('*') === -1) {
          reg += '$';
        }

        this.statesSubscribes[id] = {
          reg: new RegExp(reg),
          cbs: []
        };
        this.statesSubscribes[id].cbs.push(cb);

        if (this.connected) {
          this._socket.emit('subscribe', id);
        }
      } else {
        !this.statesSubscribes[id].cbs.includes(cb) && this.statesSubscribes[id].cbs.push(cb);
      }

      if (typeof cb === 'function' && this.connected) {
        if (binary) {
          this.getBinaryState(id).then(function (base64) {
            return cb(id, base64);
          })["catch"](function (e) {
            return console.error("Cannot getForeignStates \"".concat(id, "\": ").concat(JSON.stringify(e)));
          });
        } else {
          this._socket.emit('getForeignStates', id, function (err, states) {
            err && console.error("Cannot getForeignStates \"".concat(id, "\": ").concat(JSON.stringify(err)));
            states && Object.keys(states).forEach(function (id) {
              return cb(id, states[id]);
            });
          });
        }
      }
    }
    /**
     * Unsubscribes all callbacks from changes of the given state.
     * @param {string} id The ioBroker state ID.
     */

    /**
    * Unsubscribes the given callback from changes of the given state.
    * @param {string} id The ioBroker state ID.
    * @param {ioBroker.StateChangeHandler} cb The callback.
    */

  }, {
    key: "unsubscribeState",
    value: function unsubscribeState(id, cb) {
      if (this.statesSubscribes[id]) {
        if (cb) {
          var pos = this.statesSubscribes[id].cbs.indexOf(cb);
          pos !== -1 && this.statesSubscribes[id].cbs.splice(pos, 1);
        } else {
          this.statesSubscribes[id].cbs = [];
        }

        if (!this.statesSubscribes[id].cbs || !this.statesSubscribes[id].cbs.length) {
          delete this.statesSubscribes[id];
          this.connected && this._socket.emit('unsubscribe', id);
        }
      }
    }
    /**
     * Subscribe to changes of the given object.
     * @param {string} id The ioBroker object ID.
     * @param {import('./types').ObjectChangeHandler} cb The callback.
     * @returns {Promise<void>}
     */

  }, {
    key: "subscribeObject",
    value: function subscribeObject(id, cb) {
      if (!this.objectsSubscribes[id]) {
        var reg = id.replace(/\./g, '\\.').replace(/\*/g, '.*');

        if (reg.indexOf('*') === -1) {
          reg += '$';
        }

        this.objectsSubscribes[id] = {
          reg: new RegExp(reg),
          cbs: []
        };
        this.objectsSubscribes[id].cbs.push(cb);
        this.connected && this._socket.emit('subscribeObjects', id);
      } else {
        !this.objectsSubscribes[id].cbs.includes(cb) && this.objectsSubscribes[id].cbs.push(cb);
      }

      return Promise.resolve();
    }
    /**
     * Unsubscribes all callbacks from changes of the given object.
     * @param {string} id The ioBroker object ID.
     * @returns {Promise<void>}
     */

    /**
    * Unsubscribes the given callback from changes of the given object.
    * @param {string} id The ioBroker object ID.
    * @param {import('./types').ObjectChangeHandler} cb The callback.
    * @returns {Promise<void>}
    */

  }, {
    key: "unsubscribeObject",
    value: function unsubscribeObject(id, cb) {
      if (this.objectsSubscribes[id]) {
        if (cb) {
          var pos = this.objectsSubscribes[id].cbs.indexOf(cb);
          pos !== -1 && this.objectsSubscribes[id].cbs.splice(pos, 1);
        } else {
          this.objectsSubscribes[id].cbs = [];
        }

        if (this.connected && (!this.objectsSubscribes[id].cbs || !this.objectsSubscribes[id].cbs.length)) {
          delete this.objectsSubscribes[id];
          this.connected && this._socket.emit('unsubscribeObjects', id);
        }
      }

      return Promise.resolve();
    }
    /**
     * Called internally.
     * @private
     * @param {string} id
     * @param {ioBroker.Object | null | undefined} obj
     */

  }, {
    key: "objectChange",
    value: function objectChange(id, obj) {
      var _this4 = this;

      // update main.objects cache
      if (!this.objects) {
        return;
      }
      /** @type {import("./types").OldObject} */


      var oldObj;
      var changed = false;

      if (obj) {
        if (obj._rev && this.objects[id]) {
          this.objects[id]._rev = obj._rev;
        }

        if (this.objects[id]) {
          oldObj = {
            _id: id,
            type: this.objects[id].type
          };
        }

        if (!this.objects[id] || JSON.stringify(this.objects[id]) !== JSON.stringify(obj)) {
          this.objects[id] = obj;
          changed = true;
        }
      } else if (this.objects[id]) {
        oldObj = {
          _id: id,
          type: this.objects[id].type
        };
        delete this.objects[id];
        changed = true;
      }

      Object.keys(this.objectsSubscribes).forEach(function (_id) {
        if (_id === id || _this4.objectsSubscribes[_id].reg.test(id)) {
          _this4.objectsSubscribes[_id].cbs.forEach(function (cb) {
            return cb(id, obj, oldObj);
          });
        }
      });

      if (changed && this.props.onObjectChange) {
        this.props.onObjectChange(id, obj);
      }
    }
    /**
     * Called internally.
     * @private
     * @param {string} id
     * @param {ioBroker.State | null | undefined} state
     */

  }, {
    key: "stateChange",
    value: function stateChange(id, state) {
      for (var task in this.statesSubscribes) {
        if (this.statesSubscribes.hasOwnProperty(task) && this.statesSubscribes[task].reg.test(id)) {
          this.statesSubscribes[task].cbs.forEach(function (cb) {
            return cb(id, state);
          });
        }
      }
    }
    /**
     * Gets all states.
     * @param {boolean} disableProgressUpdate don't call onProgress() when done
     * @returns {Promise<Record<string, ioBroker.State>>}
     */

  }, {
    key: "getStates",
    value: function getStates(disableProgressUpdate) {
      var _this5 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this5._socket.emit('getStates', function (err, res) {
          _this5.states = res;
          !disableProgressUpdate && _this5.onProgress(PROGRESS.STATES_LOADED);
          return err ? reject(err) : resolve(_this5.states);
        });
      });
    }
    /**
     * Gets the given state.
     * @param {string} id The state ID.
     * @returns {Promise<ioBroker.State | null | undefined>}
     */

  }, {
    key: "getState",
    value: function getState(id) {
      var _this6 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this6._socket.emit('getState', id, function (err, state) {
          return err ? reject(err) : resolve(state);
        });
      });
    }
    /**
     * Gets the given binary state.
     * @param {string} id The state ID.
     * @returns {Promise<Buffer | undefined>}
     */

  }, {
    key: "getBinaryState",
    value: function getBinaryState(id) {
      var _this7 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      } // the data will come in base64


      return new Promise(function (resolve, reject) {
        return _this7._socket.emit('getBinaryState', id, function (err, state) {
          return err ? reject(err) : resolve(state);
        });
      });
    }
    /**
     * Sets the given binary state.
     * @param {string} id The state ID.
     * @param {string} base64 The Base64 encoded binary data.
     * @returns {Promise<void>}
     */

  }, {
    key: "setBinaryState",
    value: function setBinaryState(id, base64) {
      var _this8 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      } // the data will come in base64


      return new Promise(function (resolve, reject) {
        return _this8._socket.emit('setBinaryState', id, base64, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Sets the given state value.
     * @param {string} id The state ID.
     * @param {string | number | boolean | ioBroker.State | ioBroker.SettableState | null} val The state value.
     * @returns {Promise<void>}
     */

  }, {
    key: "setState",
    value: function setState(id, val) {
      var _this9 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this9._socket.emit('setState', id, val, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Gets all objects.
     * @param {(objects?: Record<string, ioBroker.Object>) => void} update Callback that is executed when all objects are retrieved.
     * @returns {void}
     */

    /**
    * Gets all objects.
    * @param {boolean} update Set to true to retrieve all objects from the server (instead of using the local cache).
    * @param {boolean} disableProgressUpdate don't call onProgress() when done
    * @returns {Promise<Record<string, ioBroker.Object>> | undefined}
    */

  }, {
    key: "getObjects",
    value: function getObjects(update, disableProgressUpdate) {
      var _this10 = this;

      if (typeof update === 'function') {
        var callback = update; // BF(2020_06_01): old code, must be removed when adapter-react will be updated

        if (!this.connected) {
          console.error(NOT_CONNECTED);
          callback();
        } else {
          if (this.objects && Object.keys(this.objects).length > 2) {
            setTimeout(function () {
              return callback(_this10.objects);
            }, 100);
          } else {
            this._socket.emit('getAllObjects', function (err, res) {
              _this10.objects = res || {};
              disableProgressUpdate && _this10.onProgress(PROGRESS.OBJECTS_LOADED);
              callback(_this10.objects);
            });
          }
        }
      } else {
        if (!this.connected) {
          return Promise.reject(NOT_CONNECTED);
        } else {
          return new Promise(function (resolve, reject) {
            if (!update && _this10.objects) {
              return resolve(_this10.objects);
            }

            _this10._socket.emit('getAllObjects', function (err, res) {
              _this10.objects = res;
              disableProgressUpdate && _this10.onProgress(PROGRESS.OBJECTS_LOADED);
              err ? reject(err) : resolve(_this10.objects);
            });
          });
        }
      }
    }
    /**
     * Called internally.
     * @private
     * @param {boolean} isEnable
     */

  }, {
    key: "_subscribe",
    value: function _subscribe(isEnable) {
      var _this11 = this;

      if (isEnable && !this.subscribed) {
        this.subscribed = true;
        this.autoSubscribes.forEach(function (id) {
          return _this11._socket.emit('subscribeObjects', id);
        }); // re subscribe objects

        Object.keys(this.objectsSubscribes).forEach(function (id) {
          return _this11._socket.emit('subscribeObjects', id);
        }); // re-subscribe logs

        this.autoSubscribeLog && this._socket.emit('requireLog', true); // re subscribe states

        Object.keys(this.statesSubscribes).forEach(function (id) {
          return _this11._socket.emit('subscribe', id);
        });
      } else if (!isEnable && this.subscribed) {
        this.subscribed = false; // un-subscribe objects

        this.autoSubscribes.forEach(function (id) {
          return _this11._socket.emit('unsubscribeObjects', id);
        });
        Object.keys(this.objectsSubscribes).forEach(function (id) {
          return _this11._socket.emit('unsubscribeObjects', id);
        }); // un-subscribe logs

        this.autoSubscribeLog && this._socket.emit('requireLog', false); // un-subscribe states

        Object.keys(this.statesSubscribes).forEach(function (id) {
          return _this11._socket.emit('unsubscribe', id);
        });
      }
    }
    /**
     * Requests log updates.
     * @param {boolean} isEnabled Set to true to get logs.
     * @returns {Promise<void>}
     */

  }, {
    key: "requireLog",
    value: function requireLog(isEnabled) {
      var _this12 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this12._socket.emit('requireLog', isEnabled, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Deletes the given object.
     * @param {string} id The object ID.
     * @param {boolean} maintenance Force deletion of non conform IDs.
     * @returns {Promise<void>}
     */

  }, {
    key: "delObject",
    value: function delObject(id, maintenance) {
      var _this13 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this13._socket.emit('delObject', id, {
          maintenance: !!maintenance
        }, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Deletes the given object and all its children.
     * @param {string} id The object ID.
     * @param {boolean} maintenance Force deletion of non conform IDs.
     * @returns {Promise<void>}
     */

  }, {
    key: "delObjects",
    value: function delObjects(id, maintenance) {
      var _this14 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this14._socket.emit('delObjects', id, {
          maintenance: !!maintenance
        }, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Sets the object.
     * @param {string} id The object ID.
     * @param {ioBroker.SettableObject} obj The object.
     * @returns {Promise<void>}
     */

  }, {
    key: "setObject",
    value: function setObject(id, obj) {
      var _this15 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      if (!obj) {
        return Promise.reject('Null object is not allowed');
      }

      obj = JSON.parse(JSON.stringify(obj));

      if (obj.hasOwnProperty('from')) {
        delete obj.from;
      }

      if (obj.hasOwnProperty('user')) {
        delete obj.user;
      }

      if (obj.hasOwnProperty('ts')) {
        delete obj.ts;
      }

      return new Promise(function (resolve, reject) {
        return _this15._socket.emit('setObject', id, obj, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Gets the object with the given id from the server.
     * @param {string} id The object ID.
     * @returns {ioBroker.GetObjectPromise} The object.
     */

  }, {
    key: "getObject",
    value: function getObject(id) {
      var _this16 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this16._socket.emit('getObject', id, function (err, obj) {
          return err ? reject(err) : resolve(obj);
        });
      });
    }
    /**
     * Get all adapter instances.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */

    /**
    * Get all instances of the given adapter.
    * @param {string} adapter The name of the adapter.
    * @param {boolean} [update] Force update.
    * @returns {Promise<ioBroker.Object[]>}
    */

  }, {
    key: "getAdapterInstances",
    value: function getAdapterInstances(adapter, update) {
      var _this17 = this;

      if (typeof adapter === 'boolean') {
        update = adapter;
        adapter = '';
      }

      adapter = adapter || '';

      if (!update && this._promises['instances_' + adapter]) {
        return this._promises['instances_' + adapter];
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises['instances_' + adapter] = new Promise(function (resolve, reject) {
        return _this17._socket.emit('getAdapterInstances', adapter, function (err, instances) {
          return err ? reject(err) : resolve(instances);
        });
      });
      return this._promises['instances_' + adapter];
    }
    /**
     * Get all adapters.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */

    /**
    * Get adapters with the given name.
    * @param {string} adapter The name of the adapter.
    * @param {boolean} [update] Force update.
    * @returns {Promise<ioBroker.Object[]>}
    */

  }, {
    key: "getAdapters",
    value: function getAdapters(adapter, update) {
      var _this18 = this;

      if (typeof adapter === 'boolean') {
        update = adapter;
        adapter = '';
      }

      adapter = adapter || '';

      if (!update && this._promises['adapter_' + adapter]) {
        return this._promises['adapter_' + adapter];
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises['adapter_' + adapter] = new Promise(function (resolve, reject) {
        return _this18._socket.emit('getAdapterInstances', adapter, function (err, instances) {
          return err ? reject(err) : resolve(instances);
        });
      });
      return this._promises['adapter_' + adapter];
    }
    /**
     * Called internally.
     * @private
     * @param {any[]} objs
     * @param {(err?: any) => void} cb
     */

  }, {
    key: "_renameGroups",
    value: function _renameGroups(objs, cb) {
      var _this19 = this;

      if (!objs || !objs.length) {
        cb && cb();
      } else {
        var obj = objs.pop();
        this.delObject(obj._id).then(function () {
          obj._id = obj.newId;
          delete obj.newId;
          return _this19.setObject(obj._id, obj);
        }).then(function () {
          return setTimeout(function () {
            return _this19._renameGroups(objs, cb);
          }, 0);
        })["catch"](function (err) {
          return cb && cb(err);
        });
      }
    }
    /**
     * Rename a group.
     * @param {string} id The id.
     * @param {string} newId The new id.
     * @param {string | { [lang in ioBroker.Languages]?: string; }} newName The new name.
     */

  }, {
    key: "renameGroup",
    value: function renameGroup(id, newId, newName) {
      var _this20 = this;

      return this.getGroups(true).then(function (groups) {
        if (groups.length) {
          // find all elements
          var groupsToRename = groups.filter(function (group) {
            return group._id.startsWith(id + '.');
          }).forEach(function (group) {
            return group.newId = newId + group._id.substring(id.length);
          });
          return new Promise(function (resolve, reject) {
            return _this20._renameGroups(groupsToRename, function (err) {
              return err ? reject(err) : resolve();
            });
          }).then(function () {
            var obj = groups.find(function (group) {
              return group._id === id;
            });

            if (obj) {
              obj._id = newId;

              if (newName !== undefined) {
                obj.common = obj.common || {};
                obj.common.name = newName;
              }

              return _this20.setObject(obj._id, obj);
            }
          });
        }
      });
    }
    /**
     * Sends a message to a specific instance or all instances of some specific adapter.
     * @param {string} instance The instance to send this message to.
     * @param {string} [command] Command name of the target instance.
     * @param {ioBroker.MessagePayload} [data] The message data to send.
     * @returns {Promise<ioBroker.Message | undefined>}
     */

  }, {
    key: "sendTo",
    value: function sendTo(instance, command, data) {
      var _this21 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve) {
        return _this21._socket.emit('sendTo', instance, command, data, function (result) {
          return resolve(result);
        });
      });
    }
    /**
     * Extend an object and create it if it might not exist.
     * @param {string} id The id.
     * @param {ioBroker.PartialObject} obj The object.
     */

  }, {
    key: "extendObject",
    value: function extendObject(id, obj) {
      var _this22 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      obj = JSON.parse(JSON.stringify(obj));

      if (obj.hasOwnProperty('from')) {
        delete obj.from;
      }

      if (obj.hasOwnProperty('user')) {
        delete obj.user;
      }

      if (obj.hasOwnProperty('ts')) {
        delete obj.ts;
      }

      return new Promise(function (resolve, reject) {
        return _this22._socket.emit('extendObject', id, obj, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Register a handler for log messages.
     * @param {(message: string) => void} handler The handler.
     */

  }, {
    key: "registerLogHandler",
    value: function registerLogHandler(handler) {
      !this.onLogHandlers.includes(handler) && this.onLogHandlers.push(handler);
    }
    /**
     * Unregister a handler for log messages.
     * @param {(message: string) => void} handler The handler.
     */

  }, {
    key: "unregisterLogHandler",
    value: function unregisterLogHandler(handler) {
      var pos = this.onLogHandlers.indexOf(handler);
      pos !== -1 && this.onLogHandlers.splice(pos, 1);
    }
    /**
     * Register a handler for the connection state.
     * @param {(connected: boolean) => void} handler The handler.
     */

  }, {
    key: "registerConnectionHandler",
    value: function registerConnectionHandler(handler) {
      !this.onConnectionHandlers.includes(handler) && this.onConnectionHandlers.push(handler);
    }
    /**
     * Unregister a handler for the connection state.
     * @param {(connected: boolean) => void} handler The handler.
     */

  }, {
    key: "unregisterConnectionHandler",
    value: function unregisterConnectionHandler(handler) {
      var pos = this.onConnectionHandlers.indexOf(handler);
      pos !== -1 && this.onConnectionHandlers.splice(pos, 1);
    }
    /**
     * Set the handler for standard output of a command.
     * @param {(id: string, text: string) => void} handler The handler.
     */

  }, {
    key: "registerCmdStdoutHandler",
    value: function registerCmdStdoutHandler(handler) {
      this.onCmdStdoutHandler = handler;
    }
    /**
     * Unset the handler for standard output of a command.
     * @param {(id: string, text: string) => void} handler The handler.
     */

  }, {
    key: "unregisterCmdStdoutHandler",
    value: function unregisterCmdStdoutHandler(handler) {
      this.onCmdStdoutHandler = null;
    }
    /**
     * Set the handler for standard error of a command.
     * @param {(id: string, text: string) => void} handler The handler.
     */

  }, {
    key: "registerCmdStderrHandler",
    value: function registerCmdStderrHandler(handler) {
      this.onCmdStderrHandler = handler;
    }
    /**
     * Unset the handler for standard error of a command.
     * @param {(id: string, text: string) => void} handler The handler.
     */

  }, {
    key: "unregisterCmdStderrHandler",
    value: function unregisterCmdStderrHandler(handler) {
      this.onCmdStderrHandler = null;
    }
    /**
     * Set the handler for exit of a command.
     * @param {(id: string, exitCode: number) => void} handler The handler.
     */

  }, {
    key: "registerCmdExitHandler",
    value: function registerCmdExitHandler(handler) {
      this.onCmdExitHandler = handler;
    }
    /**
     * Unset the handler for exit of a command.
     * @param {(id: string, exitCode: number) => void} handler The handler.
     */

  }, {
    key: "unregisterCmdExitHandler",
    value: function unregisterCmdExitHandler(handler) {
      this.onCmdExitHandler = null;
    }
    /**
     * Get all enums with the given name.
     * @param {string} [_enum] The name of the enum
     * @param {boolean} [update] Force update.
     * @returns {Promise<Record<string, ioBroker.Object>>}
     */

  }, {
    key: "getEnums",
    value: function getEnums(_enum, update) {
      var _this23 = this;

      if (!update && this._promises['enums_' + (_enum || 'all')]) {
        return this._promises['enums_' + (_enum || 'all')];
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises['enums_' + (_enum || 'all')] = new Promise(function (resolve, reject) {
        _this23._socket.emit('getObjectView', 'system', 'enum', {
          startkey: 'enum.' + (_enum || ''),
          endkey: 'enum.' + (_enum ? _enum + '.' : '') + "\u9999"
        }, function (err, res) {
          if (!err && res) {
            var _res = {};

            for (var i = 0; i < res.rows.length; i++) {
              if (_enum && res.rows[i].id === 'enum.' + _enum) {
                continue;
              }

              _res[res.rows[i].id] = res.rows[i].value;
            }

            resolve(_res);
          } else {
            reject(err);
          }
        });
      });
      return this._promises['enums_' + (_enum || 'all')];
    }
    /**
     * Query a predefined object view.
     * @param {string} start The start ID.
     * @param {string} end The end ID.
     * @param {string} type The type of object.
     * @returns {Promise<Record<string, ioBroker.Object>>}
     */

  }, {
    key: "getObjectView",
    value: function getObjectView(start, end, type) {
      var _this24 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      start = start || '';
      end = end || "\u9999";
      return new Promise(function (resolve, reject) {
        _this24._socket.emit('getObjectView', 'system', type, {
          startkey: start,
          endkey: end
        }, function (err, res) {
          if (!err) {
            var _res = {};

            if (res && res.rows) {
              for (var i = 0; i < res.rows.length; i++) {
                _res[res.rows[i].id] = res.rows[i].value;
              }
            }

            resolve(_res);
          } else {
            reject(err);
          }
        });
      });
    }
    /**
     * Get the stored certificates.
     * @param {boolean} [update] Force update.
     * @returns {Promise<{name: string; type: 'public' | 'private' | 'chained'}[]>}
     */

  }, {
    key: "getCertificates",
    value: function getCertificates(update) {
      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (this._promises.cert && !update) {
        return this._promises.cert;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.cert = this.getObject('system.certificates').then(function (res) {
        var certs = [];

        if (res && res["native"] && res["native"].certificates) {
          Object.keys(res["native"].certificates).forEach(function (c) {
            var cert = res["native"].certificates[c];

            if (!cert) {
              return;
            }

            var _cert = {
              name: c,
              type: ''
            }; // If it is filename, it could be everything

            if (cert.length < 700 && (cert.indexOf('/') !== -1 || cert.indexOf('\\') !== -1)) {
              if (c.toLowerCase().includes('private')) {
                _cert.type = 'private';
              } else if (cert.toLowerCase().includes('private')) {
                _cert.type = 'private';
              } else if (c.toLowerCase().includes('public')) {
                _cert.type = 'public';
              } else if (cert.toLowerCase().includes('public')) {
                _cert.type = 'public';
              }

              certs.push(_cert);
            } else {
              _cert.type = cert.substring(0, '-----BEGIN RSA PRIVATE KEY'.length) === '-----BEGIN RSA PRIVATE KEY' || cert.substring(0, '-----BEGIN PRIVATE KEY'.length) === '-----BEGIN PRIVATE KEY' ? 'private' : 'public';

              if (_cert.type === 'public') {
                var m = cert.split('-----END CERTIFICATE-----');

                if (m.filter(function (t) {
                  return t.replace(/\r\n|\r|\n/, '').trim();
                }).length > 1) {
                  _cert.type = 'chained';
                }
              }

              certs.push(_cert);
            }
          });
        }

        return certs;
      });
      return this._promises.cert;
    }
    /**
     * Get the logs from a host (only for admin connection).
     * @param {string} host
     * @param {number} [linesNumber]
     * @returns {Promise<string[]>}
     */

  }, {
    key: "getLogs",
    value: function getLogs(host, linesNumber) {
      var _this25 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve) {
        return _this25._socket.emit('sendToHost', host, 'getLogs', linesNumber || 200, function (lines) {
          return resolve(lines);
        });
      });
    }
    /**
     * Get the log files (only for admin connection).
     * @returns {Promise<string[]>}
     */

  }, {
    key: "getLogsFiles",
    value: function getLogsFiles() {
      var _this26 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this26._socket.emit('readLogs', function (err, files) {
          return err ? reject(err) : resolve(files);
        });
      });
    }
    /**
     * Delete the logs from a host (only for admin connection).
     * @param {string} host
     * @returns {Promise<void>}
     */

  }, {
    key: "delLogs",
    value: function delLogs(host) {
      var _this27 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this27._socket.emit('sendToHost', host, 'delLogs', null, function (error) {
          return error ? reject(error) : resolve();
        });
      });
    }
    /**
     * Read the meta items.
     * @returns {Promise<ioBroker.Object[]>}
     */

  }, {
    key: "readMetaItems",
    value: function readMetaItems() {
      var _this28 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this28._socket.emit('getObjectView', 'system', 'meta', {
          startkey: '',
          endkey: "\u9999"
        }, function (err, objs) {
          return err ? reject(err) : resolve(objs.rows && objs.rows.map(function (obj) {
            return obj.value;
          }));
        });
      });
    }
    /**
     * Read the directory of an adapter.
     * @param {string} adapter The adapter name.
     * @param {string} fileName The directory name.
     * @returns {Promise<ioBroker.ReadDirResult[]>}
     */

  }, {
    key: "readDir",
    value: function readDir(adapter, fileName) {
      var _this29 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this29._socket.emit('readDir', adapter, fileName, function (err, files) {
          return err ? reject(err) : resolve(files);
        });
      });
    }
  }, {
    key: "readFile",
    value: function readFile(adapter, fileName, base64) {
      var _this30 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        if (!base64) {
          _this30._socket.emit('readFile', adapter, fileName, function (err, data, type) {
            err ? reject(err) : resolve(data, type);
          });
        } else {
          _this30._socket.emit('readFile64', adapter, fileName, base64, function (err, data) {
            return err ? reject(err) : resolve(data);
          });
        }

        ;
      });
    }
    /**
     * Write a file of an adapter.
     * @param {string} adapter The adapter name.
     * @param {string} fileName The file name.
     * @param {Buffer | string} data The data (if it's a Buffer, it will be converted to Base64).
     * @returns {Promise<void>}
     */

  }, {
    key: "writeFile64",
    value: function writeFile64(adapter, fileName, data) {
      var _this31 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        if (typeof data === 'string') {
          _this31._socket.emit('writeFile', adapter, fileName, data, function (err) {
            return err ? reject(err) : resolve();
          });
        } else {
          var base64 = btoa(new Uint8Array(data).reduce(function (data, _byte) {
            return data + String.fromCharCode(_byte);
          }, ''));

          _this31._socket.emit('writeFile64', adapter, fileName, base64, function (err) {
            return err ? reject(err) : resolve();
          });
        }
      });
    }
    /**
     * Delete a file of an adapter.
     * @param {string} adapter The adapter name.
     * @param {string} fileName The file name.
     * @returns {Promise<void>}
     */

  }, {
    key: "deleteFile",
    value: function deleteFile(adapter, fileName) {
      var _this32 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this32._socket.emit('deleteFile', adapter, fileName, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Delete a folder of an adapter.
     * @param {string} adapter The adapter name.
     * @param {string} folderName The folder name.
     * @returns {Promise<void>}
     */

  }, {
    key: "deleteFolder",
    value: function deleteFolder(adapter, folderName) {
      var _this33 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this33._socket.emit('deleteFolder', adapter, folderName, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Get the list of all hosts.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */

  }, {
    key: "getHosts",
    value: function getHosts(update) {
      var _this34 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!update && this._promises.hosts) {
        return this._promises.hosts;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.hosts = new Promise(function (resolve, reject) {
        return _this34._socket.emit('getObjectView', 'system', 'host', {
          startkey: 'system.host.',
          endkey: "system.host.\u9999"
        }, function (err, doc) {
          if (err) {
            reject(err);
          } else {
            resolve(doc.rows.map(function (item) {
              return item.value;
            }));
          }
        });
      });
      return this._promises.hosts;
    }
    /**
     * Get the list of all users.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */

  }, {
    key: "getUsers",
    value: function getUsers(update) {
      var _this35 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!update && this._promises.users) {
        return this._promises.users;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.users = new Promise(function (resolve, reject) {
        return _this35._socket.emit('getObjectView', 'system', 'user', {
          startkey: 'system.user.',
          endkey: "system.user.\u9999"
        }, function (err, doc) {
          if (err) {
            reject(err);
          } else {
            resolve(doc.rows.map(function (item) {
              return item.value;
            }));
          }
        });
      });
      return this._promises.users;
    }
    /**
     * Get the list of all groups.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */

  }, {
    key: "getGroups",
    value: function getGroups(update) {
      var _this36 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!update && this._promises.groups) {
        return this._promises.groups;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.groups = new Promise(function (resolve, reject) {
        return _this36._socket.emit('getObjectView', 'system', 'group', {
          startkey: 'system.group.',
          endkey: "system.group.\u9999"
        }, function (err, doc) {
          if (err) {
            reject(err);
          } else {
            resolve(doc.rows.map(function (item) {
              return item.value;
            }));
          }
        });
      });
      return this._promises.groups;
    }
    /**
     * Get the host information.
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @param {number} [timeoutMs] optional read timeout.
     * @returns {Promise<any>}
     */

  }, {
    key: "getHostInfo",
    value: function getHostInfo(host, update, timeoutMs) {
      var _this37 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!host.startsWith('system.host.')) {
        host += 'system.host.' + host;
      }

      if (!update && this._promises['hostInfo' + host]) {
        return this._promises['hostInfo' + host];
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises['hostInfo' + host] = new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          if (timeout) {
            timeout = null;
            reject('getHostInfo timeout');
          }
        }, timeoutMs || _this37.props.cmdTimeout);

        _this37._socket.emit('sendToHost', host, 'getHostInfo', null, function (data) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;

            if (data === PERMISSION_ERROR) {
              reject('May not read "getHostInfo"');
            } else if (!data) {
              reject('Cannot read "getHostInfo"');
            } else {
              resolve(data);
            }
          }
        });
      });
      return this._promises['hostInfo' + host];
    }
    /**
     * Get the host information (short version).
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @param {number} [timeoutMs] optional read timeout.
     * @returns {Promise<any>}
     */

  }, {
    key: "getHostInfoShort",
    value: function getHostInfoShort(host, update, timeoutMs) {
      var _this38 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!host.startsWith('system.host.')) {
        host += 'system.host.' + host;
      }

      if (!update && this._promises['hostInfoShort' + host]) {
        return this._promises['hostInfoShort' + host];
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises['hostInfoShort' + host] = new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          if (timeout) {
            timeout = null;
            reject('hostInfoShort timeout');
          }
        }, timeoutMs || _this38.props.cmdTimeout);

        _this38._socket.emit('sendToHost', host, 'getHostInfoShort', null, function (data) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;

            if (data === PERMISSION_ERROR) {
              reject('May not read "getHostInfoShort"');
            } else if (!data) {
              reject('Cannot read "getHostInfoShort"');
            } else {
              resolve(data);
            }
          }
        });
      });
      return this._promises['hostInfoShort' + host];
    }
    /**
     * Get the repository.
     * @param {string} host
     * @param {any} [args]
     * @param {boolean} [update] Force update.
     * @param {number} [timeoutMs] timeout in ms.
     * @returns {Promise<any>}
     */

  }, {
    key: "getRepository",
    value: function getRepository(host, args, update, timeoutMs) {
      var _this39 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!update && this._promises.repo) {
        return this._promises.repo;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      if (!host.startsWith('system.host.')) {
        host += 'system.host.' + host;
      }

      this._promises.repo = new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          if (timeout) {
            timeout = null;
            reject('getRepository timeout');
          }
        }, timeoutMs || _this39.props.cmdTimeout);

        _this39._socket.emit('sendToHost', host, 'getRepository', args, function (data) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;

            if (data === PERMISSION_ERROR) {
              reject('May not read "getRepository"');
            } else if (!data) {
              reject('Cannot read "getRepository"');
            } else {
              resolve(data);
            }
          }
        });
      });
      return this._promises.repo;
    }
    /**
     * Get the installed.
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @param {number} [cmdTimeout] timeout in ms (optional)
     * @returns {Promise<any>}
     */

  }, {
    key: "getInstalled",
    value: function getInstalled(host, update, cmdTimeout) {
      var _this40 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      this._promises.installed = this._promises.installed || {};

      if (!update && this._promises.installed[host]) {
        return this._promises.installed[host];
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      if (!host.startsWith('system.host.')) {
        host += 'system.host.' + host;
      }

      this._promises.installed[host] = new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          if (timeout) {
            timeout = null;
            reject('getInstalled timeout');
          }
        }, cmdTimeout || _this40.props.cmdTimeout);

        _this40._socket.emit('sendToHost', host, 'getInstalled', null, function (data) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;

            if (data === PERMISSION_ERROR) {
              reject('May not read "getInstalled"');
            } else if (!data) {
              reject('Cannot read "getInstalled"');
            } else {
              resolve(data);
            }
          }
        });
      });
      return this._promises.installed[host];
    }
    /**
     * Execute a command on a host.
     * @param {string} host The host name.
     * @param {string} cmd The command.
     * @param {string} cmdId The command ID.
     * @returns {Promise<void>}
     */

  }, {
    key: "cmdExec",
    value: function cmdExec(host, cmd, cmdId) {
      var _this41 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      if (!host.startsWith(host)) {
        host += 'system.host.' + host;
      }

      return new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          if (timeout) {
            timeout = null;
            reject('cmdExec timeout');
          }
        }, _this41.props.cmdTimeout);

        _this41._socket.emit('cmdExec', host, cmdId, cmd, null, function (err) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;

            if (err) {
              reject(err);
            } else {
              resolve();
            }
          }
        });
      });
    }
    /**
     * Checks if a given feature is supported.
     * @param {string} feature The feature to check.
     * @param {boolean} [update] Force update.
     * @returns {Promise<any>}
     */

  }, {
    key: "checkFeatureSupported",
    value: function checkFeatureSupported(feature, update) {
      var _this42 = this;

      if (!update && this._promises['supportedFeatures_' + feature]) {
        return this._promises['supportedFeatures_' + feature];
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises['supportedFeatures_' + feature] = new Promise(function (resolve, reject) {
        return _this42._socket.emit('checkFeatureSupported', feature, function (err, features) {
          err ? reject(err) : resolve(features);
        });
      });
      return this._promises['supportedFeatures_' + feature];
    }
    /**
     * Read the base settings of a given host.
     * @param {string} host
     * @returns {Promise<any>}
     */

  }, {
    key: "readBaseSettings",
    value: function readBaseSettings(host) {
      var _this43 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      return this.checkFeatureSupported('CONTROLLER_READWRITE_BASE_SETTINGS').then(function (result) {
        if (result) {
          if (!_this43.connected) {
            return Promise.reject(NOT_CONNECTED);
          }

          return new Promise(function (resolve, reject) {
            var timeout = setTimeout(function () {
              if (timeout) {
                timeout = null;
                reject('readBaseSettings timeout');
              }
            }, _this43.props.cmdTimeout);

            _this43._socket.emit('sendToHost', host, 'readBaseSettings', null, function (data) {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;

                if (data === PERMISSION_ERROR) {
                  reject('May not read "BaseSettings"');
                } else if (!data) {
                  reject('Cannot read "BaseSettings"');
                } else {
                  resolve(data);
                }
              }
            });
          });
        } else {
          return Promise.reject('Not supported');
        }
      });
    }
    /**
     * Write the base settings of a given host.
     * @param {string} host
     * @param {any} config
     * @returns {Promise<any>}
     */

  }, {
    key: "writeBaseSettings",
    value: function writeBaseSettings(host, config) {
      var _this44 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      return this.checkFeatureSupported('CONTROLLER_READWRITE_BASE_SETTINGS').then(function (result) {
        if (result) {
          if (!_this44.connected) {
            return Promise.reject(NOT_CONNECTED);
          }

          return new Promise(function (resolve, reject) {
            var timeout = setTimeout(function () {
              if (timeout) {
                timeout = null;
                reject('writeBaseSettings timeout');
              }
            }, _this44.props.cmdTimeout);

            _this44._socket.emit('sendToHost', host, 'writeBaseSettings', config, function (data) {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;

                if (data === PERMISSION_ERROR) {
                  reject('May not write "BaseSettings"');
                } else if (!data) {
                  reject('Cannot write "BaseSettings"');
                } else {
                  resolve(data);
                }
              }
            });
          });
        } else {
          return Promise.reject('Not supported');
        }
      });
    }
    /**
     * Send command to restart the iobroker on host
     * @param {string} host
     * @returns {Promise<any>}
     */

  }, {
    key: "restartController",
    value: function restartController(host) {
      var _this45 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      return new Promise(function (resolve, reject) {
        _this45._socket.emit('sendToHost', host, 'restartController', null, function (error) {
          error ? reject(error) : resolve(true);
        });
      });
    }
    /**
     * Read statistics information from host
     * @param {string} host
     * @param {string} typeOfDiag one of none, normal, no-city, extended
     * @returns {Promise<any>}
     */

  }, {
    key: "getDiagData",
    value: function getDiagData(host, typeOfDiag) {
      var _this46 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      return new Promise(function (resolve) {
        _this46._socket.emit('sendToHost', host, 'getDiagData', typeOfDiag, function (result) {
          return resolve(result);
        });
      });
    }
    /**
     * Read all states (which might not belong to this adapter) which match the given pattern.
     * @param {string} pattern
     * @returns {ioBroker.GetStatesPromise}
     */

  }, {
    key: "getForeignStates",
    value: function getForeignStates(pattern) {
      var _this47 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this47._socket.emit('getForeignStates', pattern || '*', function (err, states) {
          return err ? reject(err) : resolve(states);
        });
      });
    }
    /**
     * Get foreign objects by pattern, by specific type and resolve their enums.
     * @param {string} pattern
     * @param {string} [type]
     * @returns {ioBroker.GetObjectsPromise}
     */

  }, {
    key: "getForeignObjects",
    value: function getForeignObjects(pattern, type) {
      var _this48 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this48._socket.emit('getForeignObjects', pattern || '*', type, function (err, states) {
          return err ? reject(err) : resolve(states);
        });
      });
    }
    /**
     * Gets the system configuration.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.OtherObject>}
     */

  }, {
    key: "getSystemConfig",
    value: function getSystemConfig(update) {
      if (!update && this._promises.systemConfig) {
        return this._promises.systemConfig;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.systemConfig = this.getObject('system.config').then(function (systemConfig) {
        systemConfig = systemConfig || {};
        systemConfig.common = systemConfig.common || {};
        systemConfig["native"] = systemConfig["native"] || {};
        return systemConfig;
      });
      return this._promises.systemConfig;
    }
    /**
     * Sets the system configuration.
     * @param {ioBroker.SettableObjectWorker<ioBroker.OtherObject>} obj
     * @returns {Promise<ioBroker.SettableObjectWorker<ioBroker.OtherObject>>}
     */

  }, {
    key: "setSystemConfig",
    value: function setSystemConfig(obj) {
      var _this49 = this;

      return this.setObject('system.config', obj).then(function () {
        return _this49._promises.systemConfig = Promise.resolve(obj);
      });
    }
    /**
     * Get the raw socket.io socket.
     * @returns {any}
     */

  }, {
    key: "getRawSocket",
    value: function getRawSocket() {
      return this._socket;
    }
    /**
     * Get the history of a given state.
     * @param {string} id
     * @param {ioBroker.GetHistoryOptions} options
     * @returns {Promise<ioBroker.GetHistoryResult>}
     */

  }, {
    key: "getHistory",
    value: function getHistory(id, options) {
      var _this50 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this50._socket.emit('getHistory', id, options, function (err, values) {
          return err ? reject(err) : resolve(values);
        });
      });
    }
    /**
     * Get the history of a given state.
     * @param {string} id
     * @param {ioBroker.GetHistoryOptions} options
     * @returns {Promise<{values: ioBroker.GetHistoryResult; sesionId: string; stepIgnore: number}>}
     */

  }, {
    key: "getHistoryEx",
    value: function getHistoryEx(id, options) {
      var _this51 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this51._socket.emit('getHistory', id, options, function (err, values, stepIgnore, sessionId) {
          return err ? reject(err) : resolve({
            values: values,
            sessionId: sessionId,
            stepIgnore: stepIgnore
          });
        });
      });
    }
    /**
     * Change the password of the given user.
     * @param {string} user
     * @param {string} password
     * @returns {Promise<void>}
     */

  }, {
    key: "changePassword",
    value: function changePassword(user, password) {
      var _this52 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      return new Promise(function (resolve, reject) {
        return _this52._socket.emit('changePassword', user, password, function (err) {
          return err ? reject(err) : resolve();
        });
      });
    }
    /**
     * Get the IP addresses of the given host.
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @returns {Promise<string[]>}
     */

  }, {
    key: "getIpAddresses",
    value: function getIpAddresses(host, update) {
      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!host.startsWith('system.host.')) {
        host = 'system.host.' + host;
      }

      if (!update && this._promises['IPs_' + host]) {
        return this._promises['IPs_' + host];
      }

      this._promises['IPs_' + host] = this.getObject(host).then(function (obj) {
        return obj && obj.common ? obj.common.address || [] : [];
      });
      return this._promises['IPs_' + host];
    }
    /**
     * Get the IP addresses with interface names of the given host or find host by IP.
     * @param {string} ipOrHostName
     * @param {boolean} [update] Force update.
     * @returns {Promise<any[<name, address, family>]>}
     */

  }, {
    key: "getHostByIp",
    value: function getHostByIp(ipOrHostName, update) {
      var _this53 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (ipOrHostName.startsWith('system.host.')) {
        ipOrHostName = ipOrHostName.replace(/^system\.host\./, '');
      }

      if (!update && this._promises['rIPs_' + ipOrHostName]) {
        return this._promises['rIPs_' + ipOrHostName];
      }

      this._promises['rIPs_' + ipOrHostName] = new Promise(function (resolve) {
        return _this53._socket.emit('getHostByIp', ipOrHostName, function (ip, host) {
          var _host$native, _host$native$hardware;

          var IPs4 = [{
            name: '[IPv4] 0.0.0.0 - Listen on all IPs',
            address: '0.0.0.0',
            family: 'ipv4'
          }];
          var IPs6 = [{
            name: '[IPv6] :: - Listen on all IPs',
            address: '::',
            family: 'ipv6'
          }];

          if ((_host$native = host["native"]) !== null && _host$native !== void 0 && (_host$native$hardware = _host$native.hardware) !== null && _host$native$hardware !== void 0 && _host$native$hardware.networkInterfaces) {
            for (var eth in host["native"].hardware.networkInterfaces) {
              if (!host["native"].hardware.networkInterfaces.hasOwnProperty(eth)) {
                continue;
              }

              for (var num = 0; num < host["native"].hardware.networkInterfaces[eth].length; num++) {
                if (host["native"].hardware.networkInterfaces[eth][num].family !== 'IPv6') {
                  IPs4.push({
                    name: "[".concat(host["native"].hardware.networkInterfaces[eth][num].family, "] ").concat(host["native"].hardware.networkInterfaces[eth][num].address, " - ").concat(eth),
                    address: host["native"].hardware.networkInterfaces[eth][num].address,
                    family: 'ipv4'
                  });
                } else {
                  IPs6.push({
                    name: "[".concat(host["native"].hardware.networkInterfaces[eth][num].family, "] ").concat(host["native"].hardware.networkInterfaces[eth][num].address, " - ").concat(eth),
                    address: host["native"].hardware.networkInterfaces[eth][num].address,
                    family: 'ipv6'
                  });
                }
              }
            }
          }

          for (var i = 0; i < IPs6.length; i++) {
            IPs4.push(IPs6[i]);
          }

          resolve(IPs4);
        });
      });
      return this._promises['rIPs_' + ipOrHostName];
    }
    /**
     * Encrypt a text
     * @param {string} text
     * @returns {Promise<string>}
     */

  }, {
    key: "encrypt",
    value: function encrypt(text) {
      var _this54 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      return new Promise(function (resolve, reject) {
        return _this54._socket.emit('encrypt', text, function (err, text) {
          return err ? reject(err) : resolve(text);
        });
      });
    }
    /**
     * Decrypt a text
     * @param {string} encryptedText
     * @returns {Promise<string>}
     */

  }, {
    key: "decrypt",
    value: function decrypt(encryptedText) {
      var _this55 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      return new Promise(function (resolve, reject) {
        return _this55._socket.emit('decrypt', encryptedText, function (err, text) {
          return err ? reject(err) : resolve(text);
        });
      });
    }
    /**
     * Gets the version.
     * @returns {Promise<{version: string; serverName: string}>}
     */

  }, {
    key: "getVersion",
    value: function getVersion() {
      var _this56 = this;

      this._promises.version = this._promises.version || new Promise(function (resolve, reject) {
        return _this56._socket.emit('getVersion', function (err, version, serverName) {
          // support of old socket.io
          if (err && !version && typeof err === 'string' && err.match(/\d+\.\d+\.\d+/)) {
            resolve({
              version: err,
              serverName: 'socketio'
            });
          } else {
            return err ? reject(err) : resolve({
              version: version,
              serverName: serverName
            });
          }
        });
      });
      return this._promises.version;
    }
    /**
     * Gets the web server name.
     * @returns {Promise<string>}
     */

  }, {
    key: "getWebServerName",
    value: function getWebServerName() {
      var _this57 = this;

      this._promises.webName = this._promises.webName || new Promise(function (resolve, reject) {
        return _this57._socket.emit('getAdapterName', function (err, name) {
          return err ? reject(err) : resolve(name);
        });
      });
      return this._promises.webName;
    }
    /**
     * Gets the admin version.
     * @deprecated use getVersion()
     * @returns {Promise<{version: string; serverName: string}>}
     */

  }, {
    key: "getAdminVersion",
    value: function getAdminVersion() {
      console.log('Deprecated: use getVersion');
      return this.getVersion();
    }
    /**
     * Change access rights for file
     * @param {string} [adapter] adapter name
     * @param {string} [filename] file name with full path. it could be like vis.0/*
     * @param {object} [options] like {mode: 0x644}
     * @returns {Promise<{entries: array}>}
     */

  }, {
    key: "chmodFile",
    value: function chmodFile(adapter, filename, options) {
      var _this58 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this58._socket.emit('chmodFile', adapter, filename, options, function (err, entries, id) {
          return err ? reject(err) : resolve({
            entries: entries,
            id: id
          });
        });
      });
    }
    /**
     * Change owner or/and owner group for file
     * @param {string} [adapter] adapter name
     * @param {string} [filename] file name with full path. it could be like vis.0/*
     * @param {object} [options] like {owner: 'newOwner', ownerGroup: 'newGroup'}
     * @returns {Promise<{entries: array}>}
     */

  }, {
    key: "chownFile",
    value: function chownFile(adapter, filename, options) {
      var _this59 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this59._socket.emit('chownFile', adapter, filename, options, function (err, entries, id) {
          return err ? reject(err) : resolve({
            entries: entries,
            id: id
          });
        });
      });
    }
    /**
     * Check if the file exists
     * @param {string} [adapter] adapter name
     * @param {string} [filename] file name with full path. it could be like vis.0/*
     * @returns {Promise<boolean>}
     */

  }, {
    key: "fileExists",
    value: function fileExists(adapter, filename) {
      var _this60 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this60._socket.emit('fileExists', adapter, filename, function (err, exists) {
          return err ? reject(err) : resolve(exists);
        });
      });
    }
    /**
     * Get the alarm notifications from a host (only for admin connection).
     * @param {string} host
     * @param {string} [category] - optional
     * @returns {Promise<any>}
     */

  }, {
    key: "getNotifications",
    value: function getNotifications(host, category) {
      var _this61 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve) {
        return _this61._socket.emit('sendToHost', host, 'getNotifications', {
          category: category
        }, function (notifications) {
          return resolve(notifications);
        });
      });
    }
    /**
     * Clear the alarm notifications on a host (only for admin connection).
     * @param {string} host
     * @param {string} [category] - optional
     * @returns {Promise<any>}
     */

  }, {
    key: "clearNotifications",
    value: function clearNotifications(host, category) {
      var _this62 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve) {
        return _this62._socket.emit('sendToHost', host, 'clearNotifications', {
          category: category
        }, function (notifications) {
          return resolve(notifications);
        });
      });
    }
    /**
     * Read if only easy mode is allowed  (only for admin connection).
     * @returns {Promise<boolean>}
     */

  }, {
    key: "getIsEasyModeStrict",
    value: function getIsEasyModeStrict() {
      var _this63 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this63._socket.emit('getIsEasyModeStrict', function (error, isStrict) {
          return error ? reject(error) : resolve(isStrict);
        });
      });
    }
    /**
     * Read easy mode configuration (only for admin connection).
     * @returns {Promise<any>}
     */

  }, {
    key: "getEasyMode",
    value: function getEasyMode() {
      var _this64 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this64._socket.emit('getEasyMode', function (error, config) {
          return error ? reject(error) : resolve(config);
        });
      });
    }
    /**
     * Read current user
     * @returns {Promise<string>}
     */

  }, {
    key: "getCurrentUser",
    value: function getCurrentUser() {
      var _this65 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve) {
        return _this65._socket.emit('authEnabled', function (isSecure, user) {
          return resolve(user);
        });
      });
    }
  }, {
    key: "getCurrentSession",
    value: function getCurrentSession(cmdTimeout) {
      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        var controller = new AbortController();
        var timeout = setTimeout(function () {
          if (timeout) {
            timeout = null;
            controller.abort();
            reject('getCurrentSession timeout');
          }
        }, cmdTimeout || 5000);
        return fetch('./session', {
          signal: controller.signal
        }).then(function (res) {
          return res.json();
        }).then(function (json) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
            resolve(json);
          }
        })["catch"](function (e) {
          reject('getCurrentSession: ' + e);
        });
      });
    }
    /**
     * Read adapter ratings
     * @returns {Promise<any>}
     */

  }, {
    key: "getRatings",
    value: function getRatings(update) {
      var _this66 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      return new Promise(function (resolve, reject) {
        return _this66._socket.emit('getRatings', update, function (err, ratings) {
          return err ? reject(err) : resolve(ratings);
        });
      });
    }
    /**
     * Read current web, socketio or admin namespace, like admin.0
     * @returns {Promise<string>}
     */

  }, {
    key: "getCurrentInstance",
    value: function getCurrentInstance() {
      var _this67 = this;

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.currentInstance = this._promises.currentInstance || new Promise(function (resolve, reject) {
        return _this67._socket.emit('getCurrentInstance', function (err, namespace) {
          return err ? reject(err) : resolve(namespace);
        });
      });
      return this._promises.currentInstance;
    } // returns very optimized information for adapters to minimize connection load

  }, {
    key: "getCompactAdapters",
    value: function getCompactAdapters(update) {
      var _this68 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!update && this._promises.compactAdapters) {
        return this._promises.compactAdapters;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.compactAdapters = new Promise(function (resolve, reject) {
        return _this68._socket.emit('getCompactAdapters', function (err, systemConfig) {
          return err ? reject(err) : resolve(systemConfig);
        });
      });
      return this._promises.compactAdapters;
    } // returns very optimized information for adapters to minimize connection load

  }, {
    key: "getCompactInstances",
    value: function getCompactInstances(update) {
      var _this69 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!update && this._promises.compactInstances) {
        return this._promises.compactInstances;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.compactInstances = new Promise(function (resolve, reject) {
        return _this69._socket.emit('getCompactInstances', function (err, systemConfig) {
          return err ? reject(err) : resolve(systemConfig);
        });
      });
      return this._promises.compactInstances;
    } // returns very optimized information for adapters to minimize connection load
    // reads only version of installed adapter

  }, {
    key: "getCompactInstalled",
    value: function getCompactInstalled(host, update, cmdTimeout) {
      var _this70 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      this._promises.installedCompact = this._promises.installedCompact || {};

      if (!update && this._promises.installedCompact[host]) {
        return this._promises.installedCompact[host];
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      if (!host.startsWith('system.host.')) {
        host += 'system.host.' + host;
      }

      this._promises.installedCompact[host] = new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          if (timeout) {
            timeout = null;
            reject('getCompactInstalled timeout');
          }
        }, cmdTimeout || _this70.props.cmdTimeout);

        _this70._socket.emit('getCompactInstalled', host, function (data) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;

            if (data === PERMISSION_ERROR) {
              reject('May not read "getCompactInstalled"');
            } else if (!data) {
              reject('Cannot read "getCompactInstalled"');
            } else {
              resolve(data);
            }
          }
        });
      });
      return this._promises.installedCompact[host];
    } // returns very optimized information for adapters to minimize connection load

  }, {
    key: "getCompactSystemConfig",
    value: function getCompactSystemConfig(update) {
      var _this71 = this;

      if (!update && this._promises.systemConfigCommon) {
        return this._promises.systemConfigCommon;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.systemConfigCommon = new Promise(function (resolve, reject) {
        return _this71._socket.emit('getCompactSystemConfig', function (err, systemConfig) {
          return err ? reject(err) : resolve(systemConfig);
        });
      });
      return this._promises.systemConfigCommon;
    }
    /**
     * Get the repository in compact form (only version and icon).
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @param {number} [timeoutMs] timeout in ms.
     * @returns {Promise<any>}
     */

  }, {
    key: "getCompactRepository",
    value: function getCompactRepository(host, update, timeoutMs) {
      var _this72 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!update && this._promises.repoCompact) {
        return this._promises.repoCompact;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      if (!host.startsWith('system.host.')) {
        host += 'system.host.' + host;
      }

      this._promises.repoCompact = new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          if (timeout) {
            timeout = null;
            reject('getCompactRepository timeout');
          }
        }, timeoutMs || _this72.props.cmdTimeout);

        _this72._socket.emit('getCompactRepository', host, function (data) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;

            if (data === PERMISSION_ERROR) {
              reject('May not read "getCompactRepository"');
            } else if (!data) {
              reject('Cannot read "getCompactRepository"');
            } else {
              resolve(data);
            }
          }
        });
      });
      return this._promises.repoCompact;
    }
    /**
     * Get the list of all hosts in compact form (only _id, common.name, common.icon, common.color, native.hardware.networkInterfaces)
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */

  }, {
    key: "getCompactHosts",
    value: function getCompactHosts(update) {
      var _this73 = this;

      if (Connection.isWeb()) {
        return Promise.reject('Allowed only in admin');
      }

      if (!update && this._promises.hostsCompact) {
        return this._promises.hostsCompact;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.hostsCompact = new Promise(function (resolve, reject) {
        return _this73._socket.emit('getCompactHosts', function (err, systemConfig) {
          return err ? reject(err) : resolve(systemConfig);
        });
      });
      return this._promises.hostsCompact;
    }
    /**
     * Get uuid
     * @returns {Promise<ioBroker.Object[]>}
     */

  }, {
    key: "getUuid",
    value: function getUuid() {
      if (this._promises.uuid) {
        return this._promises.uuid;
      }

      if (!this.connected) {
        return Promise.reject(NOT_CONNECTED);
      }

      this._promises.uuid = this.getObject('system.meta.uuid').then(function (obj) {
        var _obj$native;

        return obj === null || obj === void 0 ? void 0 : (_obj$native = obj["native"]) === null || _obj$native === void 0 ? void 0 : _obj$native.uuid;
      });
      return this._promises.uuid;
    }
  }], [{
    key: "isWeb",
    value: function isWeb() {
      return window.socketUrl !== undefined;
    }
  }]);

  return Connection;
}();

Connection.Connection = {
  onLog: _propTypes["default"].func,
  onReady: _propTypes["default"].func,
  onProgress: _propTypes["default"].func
};
var _default = Connection;
exports["default"] = _default;
//# sourceMappingURL=Connection.js.map
