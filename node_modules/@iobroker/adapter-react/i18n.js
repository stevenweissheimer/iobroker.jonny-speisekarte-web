"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/***
 * Copyright 2018-2019 bluefox <dogafox@gmail.com>
 *
 * MIT License
 *
 ***/

/**
 * Translation string management.
 */
var I18n = /*#__PURE__*/function () {
  function I18n() {
    _classCallCheck(this, I18n);
  }

  _createClass(I18n, null, [{
    key: "setLanguage",
    value:
    /**
     * List of all languages with their translations.
     * @type {{ [lang in ioBroker.Languages]?: Record<string, string>; }}
     */

    /**
     * The currently displayed language.
     * @type {ioBroker.Languages}
     */

    /**
     * Set the language to display.
     * @param {ioBroker.Languages} lang
     */
    function setLanguage(lang) {
      if (lang) {
        I18n.lang = lang;
      }
    }
    /**
     * Add translations
     * User can provide two types of structures:
     * - {"word1": "translated word1", "word2": "translated word2"}, but in this case the lang must be provided
     * - {"word1": {"en": "translated en word1", "de": "translated de word1"}, "word2": {"en": "translated en word2", "de": "translated de word2"}}, but no lang must be provided
     * @param {object} words additional words for specific language
     * @param {ioBroker.Languages} lang
     */

  }, {
    key: "extendTranslations",
    value: function extendTranslations(words, lang) {
      try {
        if (!lang) {
          Object.keys(words).forEach(function (word) {
            Object.keys(words[word]).forEach(function (lang) {
              if (!I18n.translations[lang]) {
                console.warn("Used unknown language: ".concat(lang));
              }

              if (!I18n.translations[lang][word]) {
                I18n.translations[lang][word] = words[word][lang];
              } else if (I18n.translations[lang][word] !== words[word][lang]) {
                console.warn("Translation for word \"".concat(word, "\" in \"").concat(lang, "\" was ignored: existing = \"").concat(I18n.translations[lang][word], "\", new = ").concat(words[word][lang]));
              }
            });
          });
        } else {
          if (!I18n.translations[lang]) {
            console.warn("Used unknown language: ".concat(lang));
          }

          I18n.translations[lang] = I18n.translations[lang] || {};
          Object.keys(words).forEach(function (word) {
            if (!I18n.translations[lang][word]) {
              I18n.translations[lang][word] = words[word];
            } else if (I18n.translations[lang][word] !== words[word]) {
              console.warn("Translation for word \"".concat(word, "\" in \"").concat(lang, "\" was ignored: existing = \"").concat(I18n.translations[lang][word], "\", new = ").concat(words[word]));
            }
          });
        }
      } catch (e) {
        console.error("Cannot apply translations: ".concat(e));
      }
    }
    /**
     * Sets all translations (in all languages).
     * @param {{ [lang in ioBroker.Languages]?: Record<string, string>; }} translations
     */

  }, {
    key: "setTranslations",
    value: function setTranslations(translations) {
      if (translations) {
        I18n.translations = translations;
      }
    }
    /**
     * Get the currently chosen language.
     * @returns {ioBroker.Languages} The current language.
     */

  }, {
    key: "getLanguage",
    value: function getLanguage() {
      return I18n.lang;
    }
    /**
     * Translate the given string to the selected language.
     * @param {string} word The (key) word to look up the string.
     * @param {string[]} args Optional arguments which will replace the first (second, third, ...) occurence of %s
     */

  }, {
    key: "t",
    value: function t(word) {
      var translation = I18n.translations[I18n.lang];

      if (translation) {
        var w = translation[word];

        if (w) {
          word = w;
        } else {
          console.log("Translate: ".concat(word));
        }
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      for (var _i = 0, _args = args; _i < _args.length; _i++) {
        var arg = _args[_i];
        word = word.replace('%s', arg);
      }

      return word;
    }
  }]);

  return I18n;
}();
/*I18n.translations = {
    'en': require('./i18n/en'),
    'ru': require('./i18n/ru'),
    'de': require('./i18n/de'),
};
I18n.fallbacks = true;
I18n.t = function () {};*/


_defineProperty(I18n, "translations", {});

_defineProperty(I18n, "lang", window.sysLang || 'en');

var _default = I18n;
exports["default"] = _default;
//# sourceMappingURL=i18n.js.map
