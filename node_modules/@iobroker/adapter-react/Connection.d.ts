export namespace PROGRESS {
    const CONNECTING: number;
    const CONNECTED: number;
    const OBJECTS_LOADED: number;
    const READY: number;
}
export default Connection;
export namespace ERRORS {
    export { PERMISSION_ERROR };
    export { NOT_CONNECTED };
}
declare class Connection {
    /**
     * Checks if this connection is running in a web adapter and not in an admin.
     * @returns {boolean} True if running in a web adapter or in a socketio adapter.
     */
    static isWeb(): boolean;
    /**
     * @param {import('./types').ConnectionProps} props
     */
    constructor(props: import('./types').ConnectionProps);
    props: import("./types").ConnectionProps;
    autoSubscribes: string[];
    autoSubscribeLog: boolean;
    doNotLoadAllObjects: boolean;
    doNotLoadACL: boolean;
    /** @type {Record<string, ioBroker.State>} */
    states: Record<string, ioBroker.State>;
    objects: any;
    acl: any;
    firstConnect: boolean;
    waitForRestart: boolean;
    /** @type {ioBroker.Languages} */
    systemLang: ioBroker.Languages;
    connected: boolean;
    /** @type {Record<string, { reg: RegExp; cbs: ioBroker.StateChangeHandler[]}>} */
    statesSubscribes: Record<string, {
        reg: RegExp;
        cbs: ioBroker.StateChangeHandler[];
    }>;
    /** @type {Record<string, { reg: RegExp; cbs: import('./types').ObjectChangeHandler[]}>} */
    objectsSubscribes: Record<string, {
        reg: RegExp;
        cbs: import('./types').ObjectChangeHandler[];
    }>;
    onProgress: (progress: number) => void;
    onError: (err: any) => void;
    loaded: boolean;
    loadTimer: any;
    loadCounter: number;
    certPromise: any;
    /** @type {((connected: boolean) => void)[]} */
    onConnectionHandlers: ((connected: boolean) => void)[];
    /** @type {((message: string) => void)[]} */
    onLogHandlers: ((message: string) => void)[];
    /** @type {Record<string, Promise<any>>} */
    _promises: Record<string, Promise<any>>;
    /**
     * Starts the socket.io connection.
     * @returns {void}
     */
    startSocket(): void;
    scriptLoadCounter: any;
    _socket: any;
    _authTimer: any;
    subscribed: boolean;
    /**
     * Called internally.
     * @private
     * @param {boolean} isOk
     * @param {boolean} isSecure
     */
    private onPreConnect;
    isSecure: boolean;
    /**
     * Checks if the socket is connected.
     * @returns {boolean} true if connected.
     */
    isConnected(): boolean;
    /**
     * Called internally.
     * @private
     */
    private _getUserPermissions;
    /**
     * Called internally.
     * @private
     */
    private onConnect;
    systemConfig: any;
    /**
     * Called internally.
     * @private
     */
    private authenticate;
    /**
     * Subscribe to changes of the given state.
     * @param {string} id The ioBroker state ID.
     * @param {ioBroker.StateChangeHandler} cb The callback.
     */ /**
    * Subscribe to changes of the given state.
    * @param {string} id The ioBroker state ID.
    * @param {boolean} binary Set to true if the given state is binary and requires Base64 decoding.
    * @param {ioBroker.StateChangeHandler} cb The callback.
    */
    subscribeState(id: string, binary: boolean, cb: ioBroker.StateChangeHandler): void;
    /**
     * Unsubscribes all callbacks from changes of the given state.
     * @param {string} id The ioBroker state ID.
     */ /**
    * Unsubscribes the given callback from changes of the given state.
    * @param {string} id The ioBroker state ID.
    * @param {ioBroker.StateChangeHandler} cb The callback.
    */
    unsubscribeState(id: string, cb: ioBroker.StateChangeHandler): void;
    /**
     * Subscribe to changes of the given object.
     * @param {string} id The ioBroker object ID.
     * @param {import('./types').ObjectChangeHandler} cb The callback.
     * @returns {Promise<void>}
     */
    subscribeObject(id: string, cb: import('./types').ObjectChangeHandler): Promise<void>;
    /**
     * Unsubscribes all callbacks from changes of the given object.
     * @param {string} id The ioBroker object ID.
     * @returns {Promise<void>}
     */ /**
    * Unsubscribes the given callback from changes of the given object.
    * @param {string} id The ioBroker object ID.
    * @param {import('./types').ObjectChangeHandler} cb The callback.
    * @returns {Promise<void>}
    */
    unsubscribeObject(id: string, cb: import('./types').ObjectChangeHandler): Promise<void>;
    /**
     * Called internally.
     * @private
     * @param {string} id
     * @param {ioBroker.Object | null | undefined} obj
     */
    private objectChange;
    /**
     * Called internally.
     * @private
     * @param {string} id
     * @param {ioBroker.State | null | undefined} state
     */
    private stateChange;
    /**
     * Gets all states.
     * @param {boolean} disableProgressUpdate don't call onProgress() when done
     * @returns {Promise<Record<string, ioBroker.State>>}
     */
    getStates(disableProgressUpdate: boolean): Promise<Record<string, ioBroker.State>>;
    /**
     * Gets the given state.
     * @param {string} id The state ID.
     * @returns {Promise<ioBroker.State | null | undefined>}
     */
    getState(id: string): Promise<ioBroker.State | null | undefined>;
    /**
     * Gets the given binary state.
     * @param {string} id The state ID.
     * @returns {Promise<Buffer | undefined>}
     */
    getBinaryState(id: string): Promise<Buffer | undefined>;
    /**
     * Sets the given binary state.
     * @param {string} id The state ID.
     * @param {string} base64 The Base64 encoded binary data.
     * @returns {Promise<void>}
     */
    setBinaryState(id: string, base64: string): Promise<void>;
    /**
     * Sets the given state value.
     * @param {string} id The state ID.
     * @param {string | number | boolean | ioBroker.State | ioBroker.SettableState | null} val The state value.
     * @returns {Promise<void>}
     */
    setState(id: string, val: string | number | boolean | ioBroker.State | ioBroker.SettableState | null): Promise<void>;
    /**
     * Gets all objects.
     * @param {(objects?: Record<string, ioBroker.Object>) => void} update Callback that is executed when all objects are retrieved.
     * @returns {void}
     */ /**
    * Gets all objects.
    * @param {boolean} update Set to true to retrieve all objects from the server (instead of using the local cache).
    * @param {boolean} disableProgressUpdate don't call onProgress() when done
    * @returns {Promise<Record<string, ioBroker.Object>> | undefined}
    */
    getObjects(update: boolean, disableProgressUpdate: boolean): Promise<Record<string, ioBroker.Object>> | undefined;
    /**
     * Called internally.
     * @private
     * @param {boolean} isEnable
     */
    private _subscribe;
    /**
     * Requests log updates.
     * @param {boolean} isEnabled Set to true to get logs.
     * @returns {Promise<void>}
     */
    requireLog(isEnabled: boolean): Promise<void>;
    /**
     * Deletes the given object.
     * @param {string} id The object ID.
     * @param {boolean} maintenance Force deletion of non conform IDs.
     * @returns {Promise<void>}
     */
    delObject(id: string, maintenance: boolean): Promise<void>;
    /**
     * Deletes the given object and all its children.
     * @param {string} id The object ID.
     * @param {boolean} maintenance Force deletion of non conform IDs.
     * @returns {Promise<void>}
     */
    delObjects(id: string, maintenance: boolean): Promise<void>;
    /**
     * Sets the object.
     * @param {string} id The object ID.
     * @param {ioBroker.SettableObject} obj The object.
     * @returns {Promise<void>}
     */
    setObject(id: string, obj: ioBroker.SettableObject): Promise<void>;
    /**
     * Gets the object with the given id from the server.
     * @param {string} id The object ID.
     * @returns {ioBroker.GetObjectPromise} The object.
     */
    getObject(id: string): ioBroker.GetObjectPromise<string>;
    /**
     * Get all adapter instances.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */ /**
    * Get all instances of the given adapter.
    * @param {string} adapter The name of the adapter.
    * @param {boolean} [update] Force update.
    * @returns {Promise<ioBroker.Object[]>}
    */
    getAdapterInstances(adapter: string, update?: boolean): Promise<ioBroker.Object[]>;
    /**
     * Get all adapters.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */ /**
    * Get adapters with the given name.
    * @param {string} adapter The name of the adapter.
    * @param {boolean} [update] Force update.
    * @returns {Promise<ioBroker.Object[]>}
    */
    getAdapters(adapter: string, update?: boolean): Promise<ioBroker.Object[]>;
    /**
     * Called internally.
     * @private
     * @param {any[]} objs
     * @param {(err?: any) => void} cb
     */
    private _renameGroups;
    /**
     * Rename a group.
     * @param {string} id The id.
     * @param {string} newId The new id.
     * @param {string | { [lang in ioBroker.Languages]?: string; }} newName The new name.
     */
    renameGroup(id: string, newId: string, newName: string | {
        pt?: string;
        pl?: string;
        en?: string;
        de?: string;
        ru?: string;
        nl?: string;
        fr?: string;
        it?: string;
        es?: string;
        "zh-cn"?: string;
    }): Promise<void>;
    /**
     * Sends a message to a specific instance or all instances of some specific adapter.
     * @param {string} instance The instance to send this message to.
     * @param {string} [command] Command name of the target instance.
     * @param {ioBroker.MessagePayload} [data] The message data to send.
     * @returns {Promise<ioBroker.Message | undefined>}
     */
    sendTo(instance: string, command?: string, data?: ioBroker.MessagePayload): Promise<ioBroker.Message | undefined>;
    /**
     * Extend an object and create it if it might not exist.
     * @param {string} id The id.
     * @param {ioBroker.PartialObject} obj The object.
     */
    extendObject(id: string, obj: ioBroker.PartialObject): Promise<any>;
    /**
     * Register a handler for log messages.
     * @param {(message: string) => void} handler The handler.
     */
    registerLogHandler(handler: (message: string) => void): void;
    /**
     * Unregister a handler for log messages.
     * @param {(message: string) => void} handler The handler.
     */
    unregisterLogHandler(handler: (message: string) => void): void;
    /**
     * Register a handler for the connection state.
     * @param {(connected: boolean) => void} handler The handler.
     */
    registerConnectionHandler(handler: (connected: boolean) => void): void;
    /**
     * Unregister a handler for the connection state.
     * @param {(connected: boolean) => void} handler The handler.
     */
    unregisterConnectionHandler(handler: (connected: boolean) => void): void;
    /**
     * Set the handler for standard output of a command.
     * @param {(id: string, text: string) => void} handler The handler.
     */
    registerCmdStdoutHandler(handler: (id: string, text: string) => void): void;
    onCmdStdoutHandler: (id: string, text: string) => void;
    /**
     * Unset the handler for standard output of a command.
     * @param {(id: string, text: string) => void} handler The handler.
     */
    unregisterCmdStdoutHandler(handler: (id: string, text: string) => void): void;
    /**
     * Set the handler for standard error of a command.
     * @param {(id: string, text: string) => void} handler The handler.
     */
    registerCmdStderrHandler(handler: (id: string, text: string) => void): void;
    onCmdStderrHandler: (id: string, text: string) => void;
    /**
     * Unset the handler for standard error of a command.
     * @param {(id: string, text: string) => void} handler The handler.
     */
    unregisterCmdStderrHandler(handler: (id: string, text: string) => void): void;
    /**
     * Set the handler for exit of a command.
     * @param {(id: string, exitCode: number) => void} handler The handler.
     */
    registerCmdExitHandler(handler: (id: string, exitCode: number) => void): void;
    onCmdExitHandler: (id: string, exitCode: number) => void;
    /**
     * Unset the handler for exit of a command.
     * @param {(id: string, exitCode: number) => void} handler The handler.
     */
    unregisterCmdExitHandler(handler: (id: string, exitCode: number) => void): void;
    /**
     * Get all enums with the given name.
     * @param {string} [_enum] The name of the enum
     * @param {boolean} [update] Force update.
     * @returns {Promise<Record<string, ioBroker.Object>>}
     */
    getEnums(_enum?: string, update?: boolean): Promise<Record<string, ioBroker.Object>>;
    /**
     * Query a predefined object view.
     * @param {string} start The start ID.
     * @param {string} end The end ID.
     * @param {string} type The type of object.
     * @returns {Promise<Record<string, ioBroker.Object>>}
     */
    getObjectView(start: string, end: string, type: string): Promise<Record<string, ioBroker.Object>>;
    /**
     * Get the stored certificates.
     * @param {boolean} [update] Force update.
     * @returns {Promise<{name: string; type: 'public' | 'private' | 'chained'}[]>}
     */
    getCertificates(update?: boolean): Promise<{
        name: string;
        type: 'public' | 'private' | 'chained';
    }[]>;
    /**
     * Get the logs from a host (only for admin connection).
     * @param {string} host
     * @param {number} [linesNumber]
     * @returns {Promise<string[]>}
     */
    getLogs(host: string, linesNumber?: number): Promise<string[]>;
    /**
     * Get the log files (only for admin connection).
     * @returns {Promise<string[]>}
     */
    getLogsFiles(): Promise<string[]>;
    /**
     * Delete the logs from a host (only for admin connection).
     * @param {string} host
     * @returns {Promise<void>}
     */
    delLogs(host: string): Promise<void>;
    /**
     * Read the meta items.
     * @returns {Promise<ioBroker.Object[]>}
     */
    readMetaItems(): Promise<ioBroker.Object[]>;
    /**
     * Read the directory of an adapter.
     * @param {string} adapter The adapter name.
     * @param {string} fileName The directory name.
     * @returns {Promise<ioBroker.ReadDirResult[]>}
     */
    readDir(adapter: string, fileName: string): Promise<ioBroker.ReadDirResult[]>;
    readFile(adapter: any, fileName: any, base64: any): Promise<any>;
    /**
     * Write a file of an adapter.
     * @param {string} adapter The adapter name.
     * @param {string} fileName The file name.
     * @param {Buffer | string} data The data (if it's a Buffer, it will be converted to Base64).
     * @returns {Promise<void>}
     */
    writeFile64(adapter: string, fileName: string, data: Buffer | string): Promise<void>;
    /**
     * Delete a file of an adapter.
     * @param {string} adapter The adapter name.
     * @param {string} fileName The file name.
     * @returns {Promise<void>}
     */
    deleteFile(adapter: string, fileName: string): Promise<void>;
    /**
     * Delete a folder of an adapter.
     * @param {string} adapter The adapter name.
     * @param {string} folderName The folder name.
     * @returns {Promise<void>}
     */
    deleteFolder(adapter: string, folderName: string): Promise<void>;
    /**
     * Get the list of all hosts.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */
    getHosts(update?: boolean): Promise<ioBroker.Object[]>;
    /**
     * Get the list of all users.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */
    getUsers(update?: boolean): Promise<ioBroker.Object[]>;
    /**
     * Get the list of all groups.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */
    getGroups(update?: boolean): Promise<ioBroker.Object[]>;
    /**
     * Get the host information.
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @param {number} [timeoutMs] optional read timeout.
     * @returns {Promise<any>}
     */
    getHostInfo(host: string, update?: boolean, timeoutMs?: number): Promise<any>;
    /**
     * Get the host information (short version).
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @param {number} [timeoutMs] optional read timeout.
     * @returns {Promise<any>}
     */
    getHostInfoShort(host: string, update?: boolean, timeoutMs?: number): Promise<any>;
    /**
     * Get the repository.
     * @param {string} host
     * @param {any} [args]
     * @param {boolean} [update] Force update.
     * @param {number} [timeoutMs] timeout in ms.
     * @returns {Promise<any>}
     */
    getRepository(host: string, args?: any, update?: boolean, timeoutMs?: number): Promise<any>;
    /**
     * Get the installed.
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @param {number} [cmdTimeout] timeout in ms (optional)
     * @returns {Promise<any>}
     */
    getInstalled(host: string, update?: boolean, cmdTimeout?: number): Promise<any>;
    /**
     * Execute a command on a host.
     * @param {string} host The host name.
     * @param {string} cmd The command.
     * @param {string} cmdId The command ID.
     * @returns {Promise<void>}
     */
    cmdExec(host: string, cmd: string, cmdId: string): Promise<void>;
    /**
     * Checks if a given feature is supported.
     * @param {string} feature The feature to check.
     * @param {boolean} [update] Force update.
     * @returns {Promise<any>}
     */
    checkFeatureSupported(feature: string, update?: boolean): Promise<any>;
    /**
     * Read the base settings of a given host.
     * @param {string} host
     * @returns {Promise<any>}
     */
    readBaseSettings(host: string): Promise<any>;
    /**
     * Write the base settings of a given host.
     * @param {string} host
     * @param {any} config
     * @returns {Promise<any>}
     */
    writeBaseSettings(host: string, config: any): Promise<any>;
    /**
     * Send command to restart the iobroker on host
     * @param {string} host
     * @returns {Promise<any>}
     */
    restartController(host: string): Promise<any>;
    /**
     * Read statistics information from host
     * @param {string} host
     * @param {string} typeOfDiag one of none, normal, no-city, extended
     * @returns {Promise<any>}
     */
    getDiagData(host: string, typeOfDiag: string): Promise<any>;
    /**
     * Read all states (which might not belong to this adapter) which match the given pattern.
     * @param {string} pattern
     * @returns {ioBroker.GetStatesPromise}
     */
    getForeignStates(pattern: string): ioBroker.GetStatesPromise;
    /**
     * Get foreign objects by pattern, by specific type and resolve their enums.
     * @param {string} pattern
     * @param {string} [type]
     * @returns {ioBroker.GetObjectsPromise}
     */
    getForeignObjects(pattern: string, type?: string): ioBroker.GetObjectsPromise;
    /**
     * Gets the system configuration.
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.OtherObject>}
     */
    getSystemConfig(update?: boolean): Promise<ioBroker.OtherObject>;
    /**
     * Sets the system configuration.
     * @param {ioBroker.SettableObjectWorker<ioBroker.OtherObject>} obj
     * @returns {Promise<ioBroker.SettableObjectWorker<ioBroker.OtherObject>>}
     */
    setSystemConfig(obj: ioBroker.SettableObjectWorker<ioBroker.OtherObject>): Promise<ioBroker.SettableObjectWorker<ioBroker.OtherObject>>;
    /**
     * Get the raw socket.io socket.
     * @returns {any}
     */
    getRawSocket(): any;
    /**
     * Get the history of a given state.
     * @param {string} id
     * @param {ioBroker.GetHistoryOptions} options
     * @returns {Promise<ioBroker.GetHistoryResult>}
     */
    getHistory(id: string, options: ioBroker.GetHistoryOptions): Promise<ioBroker.GetHistoryResult>;
    /**
     * Get the history of a given state.
     * @param {string} id
     * @param {ioBroker.GetHistoryOptions} options
     * @returns {Promise<{values: ioBroker.GetHistoryResult; sesionId: string; stepIgnore: number}>}
     */
    getHistoryEx(id: string, options: ioBroker.GetHistoryOptions): Promise<{
        values: ioBroker.GetHistoryResult;
        sesionId: string;
        stepIgnore: number;
    }>;
    /**
     * Change the password of the given user.
     * @param {string} user
     * @param {string} password
     * @returns {Promise<void>}
     */
    changePassword(user: string, password: string): Promise<void>;
    /**
     * Get the IP addresses of the given host.
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @returns {Promise<string[]>}
     */
    getIpAddresses(host: string, update?: boolean): Promise<string[]>;
    /**
     * Get the IP addresses with interface names of the given host or find host by IP.
     * @param {string} ipOrHostName
     * @param {boolean} [update] Force update.
     * @returns {Promise<any[<name, address, family>]>}
     */
    getHostByIp(ipOrHostName: string, update?: boolean): Promise<any>;
    /**
     * Encrypt a text
     * @param {string} text
     * @returns {Promise<string>}
     */
    encrypt(text: string): Promise<string>;
    /**
     * Decrypt a text
     * @param {string} encryptedText
     * @returns {Promise<string>}
     */
    decrypt(encryptedText: string): Promise<string>;
    /**
     * Gets the version.
     * @returns {Promise<{version: string; serverName: string}>}
     */
    getVersion(): Promise<{
        version: string;
        serverName: string;
    }>;
    /**
     * Gets the web server name.
     * @returns {Promise<string>}
     */
    getWebServerName(): Promise<string>;
    /**
     * Gets the admin version.
     * @deprecated use getVersion()
     * @returns {Promise<{version: string; serverName: string}>}
     */
    getAdminVersion(): Promise<{
        version: string;
        serverName: string;
    }>;
    /**
     * Change access rights for file
     * @param {string} [adapter] adapter name
     * @param {string} [filename] file name with full path. it could be like vis.0/*
     * @param {object} [options] like {mode: 0x644}
     * @returns {Promise<{entries: array}>}
     */
    chmodFile(adapter?: string, filename?: string, options?: object): Promise<{
        entries: any[];
    }>;
    /**
     * Change owner or/and owner group for file
     * @param {string} [adapter] adapter name
     * @param {string} [filename] file name with full path. it could be like vis.0/*
     * @param {object} [options] like {owner: 'newOwner', ownerGroup: 'newGroup'}
     * @returns {Promise<{entries: array}>}
     */
    chownFile(adapter?: string, filename?: string, options?: object): Promise<{
        entries: any[];
    }>;
    /**
     * Check if the file exists
     * @param {string} [adapter] adapter name
     * @param {string} [filename] file name with full path. it could be like vis.0/*
     * @returns {Promise<boolean>}
     */
    fileExists(adapter?: string, filename?: string): Promise<boolean>;
    /**
     * Get the alarm notifications from a host (only for admin connection).
     * @param {string} host
     * @param {string} [category] - optional
     * @returns {Promise<any>}
     */
    getNotifications(host: string, category?: string): Promise<any>;
    /**
     * Clear the alarm notifications on a host (only for admin connection).
     * @param {string} host
     * @param {string} [category] - optional
     * @returns {Promise<any>}
     */
    clearNotifications(host: string, category?: string): Promise<any>;
    /**
     * Read if only easy mode is allowed  (only for admin connection).
     * @returns {Promise<boolean>}
     */
    getIsEasyModeStrict(): Promise<boolean>;
    /**
     * Read easy mode configuration (only for admin connection).
     * @returns {Promise<any>}
     */
    getEasyMode(): Promise<any>;
    /**
     * Read current user
     * @returns {Promise<string>}
     */
    getCurrentUser(): Promise<string>;
    getCurrentSession(cmdTimeout: any): Promise<any>;
    /**
     * Read adapter ratings
     * @returns {Promise<any>}
     */
    getRatings(update: any): Promise<any>;
    /**
     * Read current web, socketio or admin namespace, like admin.0
     * @returns {Promise<string>}
     */
    getCurrentInstance(): Promise<string>;
    getCompactAdapters(update: any): Promise<any>;
    getCompactInstances(update: any): Promise<any>;
    getCompactInstalled(host: any, update: any, cmdTimeout: any): any;
    getCompactSystemConfig(update: any): Promise<any>;
    /**
     * Get the repository in compact form (only version and icon).
     * @param {string} host
     * @param {boolean} [update] Force update.
     * @param {number} [timeoutMs] timeout in ms.
     * @returns {Promise<any>}
     */
    getCompactRepository(host: string, update?: boolean, timeoutMs?: number): Promise<any>;
    /**
     * Get the list of all hosts in compact form (only _id, common.name, common.icon, common.color, native.hardware.networkInterfaces)
     * @param {boolean} [update] Force update.
     * @returns {Promise<ioBroker.Object[]>}
     */
    getCompactHosts(update?: boolean): Promise<ioBroker.Object[]>;
    /**
     * Get uuid
     * @returns {Promise<ioBroker.Object[]>}
     */
    getUuid(): Promise<ioBroker.Object[]>;
}
declare namespace Connection {
    namespace Connection {
        const onLog: PropTypes.Requireable<(...args: any[]) => any>;
        const onReady: PropTypes.Requireable<(...args: any[]) => any>;
        const onProgress: PropTypes.Requireable<(...args: any[]) => any>;
    }
}
declare const PERMISSION_ERROR: "permissionError";
declare const NOT_CONNECTED: "notConnectedError";
import PropTypes from "prop-types";
